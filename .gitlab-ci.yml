---

include:
  - /.gitlab-ci/variables.yml
  - /.gitlab-ci/stages/01-quality.yml
  - /.gitlab-ci/stages/02-prepare.yml
  #
  - project: SocialGouv/gitlab-ci-yml
    file: /base_docker_kubectl_image_stage.yml
    ref: master
  - "/.gitlab-ci/.deploy-egapro-app.yml"
  - "/.gitlab-ci/.deploy-egapro-api.yml"
  - "/.gitlab-ci/.deploy-egapro-postgres.yml"
  - "/.gitlab-ci/.deploy-egapro-memcached.yml"
  - "/.gitlab-ci/.deploy-egapro-kinto.yml"

stages:
  - "Code Quality"
  - "Prepare"
  - "Registration"
  - "Create secret hors prod"
  - "Deploy to hors prod K8S"
  - "Send Url to GitHub"
  - "Make a new release"
  - "Deploy to prod K8S"
  - "Restore prod backup"


#############################################
#####       REGISTER DOCKER IMAGES        ###
#############################################

#
.register_stage commit sha: &register_stage_commit_sha
  stage: "Registration"
  image: docker:${DOCKER_VERSION}
  services:
    - docker:${DOCKER_VERSION}-dind
  before_script:
    - echo "$CI_JOB_TOKEN" | docker login ${CI_REGISTRY} -u gitlab-ci-token --password-stdin
    - docker pull ${IMAGE_NAME}:${CI_COMMIT_BEFORE_SHA} || true
  script:
    - echo "Build ${IMAGE_NAME}:${CI_COMMIT_SHA} from ${IMAGE_NAME}:${CI_COMMIT_BEFORE_SHA}"
    - docker build --cache-from ${IMAGE_NAME}:${CI_COMMIT_BEFORE_SHA} -t ${IMAGE_NAME}:${CI_COMMIT_SHA} -f ${DOCKERFILE_PATH} ${CONTEXT}
    - docker push ${IMAGE_NAME}
#

Register api image commit sha:
  <<: *register_stage_commit_sha
  variables:
    CONTEXT: .
    DOCKERFILE_PATH: packages/api/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/api
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - branches

Register app image commit sha:
  <<: *register_stage_commit_sha
  variables:
    CONTEXT: .
    DOCKERFILE_PATH: packages/app/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/app
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - branches

Register init kinto image commit sha:
  <<: *register_stage_commit_sha
  variables:
    CONTEXT: packages/kinto
    DOCKERFILE_PATH: packages/kinto/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/kinto
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - branches

#
.register_stage_tag: &register_stage_tag
  stage: "Registration"
  image: docker:${DOCKER_VERSION}
  services:
    - docker:${DOCKER_VERSION}-dind
  before_script:
    - export RELEASE_VERSION=$(printf "${CI_COMMIT_TAG}" | sed "s/^v//")
    - echo "$CI_JOB_TOKEN" | docker login ${CI_REGISTRY} -u gitlab-ci-token --password-stdin
  script:
    - echo "Build ${IMAGE_NAME}:${RELEASE_VERSION}"
    - docker build -t ${IMAGE_NAME}:${RELEASE_VERSION} -f ${DOCKERFILE_PATH} ${CONTEXT}
    - docker push ${IMAGE_NAME}:${RELEASE_VERSION}
#

Register api image tag:
  <<: *register_stage_tag
  variables:
    CONTEXT: .
    DOCKERFILE_PATH: packages/api/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/api
  only:
    - /^v.*/

Register app image tag:
  <<: *register_stage_tag
  variables:
    CONTEXT: .
    DOCKERFILE_PATH: packages/app/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/app
  only:
    - /^v.*/

Register init kinto image tag:
  <<: *register_stage_tag
  variables:
    CONTEXT: packages/kinto
    DOCKERFILE_PATH: packages/kinto/Dockerfile
    IMAGE_NAME: ${CI_REGISTRY_IMAGE}/kinto
  only:
    - /^v.*/

############################################
####          CREATE SECRET DEV          ###
############################################

#
.create_secret: &create_secret
  stage: "Create secret hors prod"
  image: ${CI_REGISTRY}/socialgouv/docker/kubectl:${KUBECTL_VERSION}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  script:
    # Create egapro secrets
    - envsubst < ./.k8s/secret/secret-dev.yml > .k8s/secret/secret-dev-${STARTUP}.yml
    - kubectl apply -f .k8s/secret/secret-dev-${STARTUP}.yml -n ${K8S_NAMESPACE}
#

Create egapro/secret (dev):
  <<: *create_secret
  before_script:
    - export NAMESPACE_ENVIRONMENT=${NAMESPACE_ENVIRONMENT:=$(printf "${CI_COMMIT_REF_NAME}" | sha1sum | cut -c1-5)}
    - export K8S_NAMESPACE=${STARTUP}-${NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Create egapro/secret (master):
  <<: *create_secret
  variables:
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
  before_script:
    - export K8S_NAMESPACE=${STARTUP}-${MASTER_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Create egapro/secret (preprod):
  <<: *create_secret
  variables:
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  before_script:
    - export K8S_NAMESPACE=${STARTUP}-${PREPROD_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/

###########################################
###       DEPLOY TO HORS PROD K8S       ###
###########################################

#
.deploy_stage: &deploy_stage
  stage: "Deploy to hors prod K8S"
  variables: &deploy_stage_variables
    IMAGE_TAG: ${CI_COMMIT_SHA}
    LETS_ENCRYPT_ISSUER: "letsencrypt-staging"
#

# Dev Environment

Deploy egapro/app (dev):
  <<: *deploy_stage
  extends: .deploy-egapro-app-k8s-dev
  variables:
    <<: *deploy_stage_variables
    PORT: ${APP_PORT}
    LIFETIME: "temporary"
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Deploy egapro/api (dev):
  <<: *deploy_stage
  extends: .deploy-egapro-api-k8s-dev
  variables:
    <<: *deploy_stage_variables
    PORT: ${API_PORT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Deploy egapro/postgres (dev):
  <<: *deploy_stage
  extends: .deploy-egapro-postgres-k8s-dev
  variables:
    <<: *deploy_stage_variables
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Deploy egapro/memcached (dev):
  <<: *deploy_stage
  extends: .deploy-egapro-memcached-k8s-dev
  variables:
    <<: *deploy_stage_variables
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Deploy egapro/kinto (dev):
  <<: *deploy_stage
  extends: .deploy-egapro-kinto-k8s-dev
  variables:
    <<: *deploy_stage_variables
    PORT: ${KINTO_PORT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

# Master Environment

Deploy egapro/app (master):
  <<: *deploy_stage
  extends: .deploy-egapro-app-k8s-master
  variables:
    <<: *deploy_stage_variables
    PORT: ${APP_PORT}
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Deploy egapro/api (master):
  <<: *deploy_stage
  extends: .deploy-egapro-api-k8s-master
  variables:
    <<: *deploy_stage_variables
    PORT: ${API_PORT}
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Deploy egapro/postgres (master):
  <<: *deploy_stage
  extends: .deploy-egapro-postgres-k8s-master
  variables:
    <<: *deploy_stage_variables
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Deploy egapro/memcached (master):
  <<: *deploy_stage
  extends: .deploy-egapro-memcached-k8s-master
  variables:
    <<: *deploy_stage_variables
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Deploy egapro/kinto (master):
  <<: *deploy_stage
  extends: .deploy-egapro-kinto-k8s-master
  variables:
    <<: *deploy_stage_variables
    NAMESPACE_ENVIRONMENT: ${MASTER_NAMESPACE_ENVIRONMENT}
    PORT: ${KINTO_PORT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master


# Preprod Environment

Deploy egapro/app (preprod):
  extends: .deploy-egapro-app-k8s-preprod
  stage: "Deploy to hors prod K8S"
  variables:
    PORT: ${APP_PORT}
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/

Deploy egapro/api (preprod):
  extends: .deploy-egapro-api-k8s-preprod
  stage: "Deploy to hors prod K8S"
  variables:
    PORT: ${API_PORT}
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/

Deploy egapro/postgres (preprod):
  extends: .deploy-egapro-postgres-k8s-preprod
  stage: "Deploy to hors prod K8S"
  variables:
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/

Deploy egapro/memcached (preprod):
  extends: .deploy-egapro-memcached-k8s-preprod
  stage: "Deploy to hors prod K8S"
  variables:
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/

Deploy egapro/kinto (preprod):
  extends: .deploy-egapro-kinto-k8s-preprod
  stage: "Deploy to hors prod K8S"
  variables:
    PORT: ${KINTO_PORT}
    NAMESPACE_ENVIRONMENT: ${PREPROD_NAMESPACE_ENVIRONMENT}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/


#############################################
#####         SEND URL TO GITHUB          ###
#############################################

.send_url_to_github_stage: &send_url_to_github_stage
  stage: "Send Url to GitHub"
  image: ${CI_REGISTRY}/${IMAGE_INFRA_BASE_NAME}/git-deploy:${INFRA_GIT_DEPLOY_VERSION}
  script:
    - export DEPLOY_ID=$(cat github_deploy_id)
    - envsubst < /scripts/send-url.sh > /scripts/send-url-to-github.sh
    - sh /scripts/send-url-to-github.sh


Send deployment url to Github (dev):
  <<: *send_url_to_github_stage
  before_script:
    - export NAMESPACE_ENVIRONMENT=${NAMESPACE_ENVIRONMENT:=$(printf "${CI_COMMIT_REF_NAME}" | sha1sum | cut -c1-5)}
    - export URL=https://${STARTUP}-${NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
  environment:
    name: ${DEV_NAMESPACE_ENVIRONMENT}
  only:
    - branches
  except:
    - master

Send deployment url to Github (master):
  <<: *send_url_to_github_stage
  before_script:
    - export URL=https://${STARTUP}-${MASTER_NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
  environment:
    name: ${MASTER_NAMESPACE_ENVIRONMENT}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master

Send deployment url to Github (preprod):
  <<: *send_url_to_github_stage
  before_script:
    - export URL=https://${STARTUP}-${PREPROD_NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
  environment:
    name: ${PREPROD_NAMESPACE_ENVIRONMENT}
  only:
    - /^v.*/


############################################
####           RELEASE VERSION           ###
############################################

Make a new release to deploy to preprod environment:
  stage: "Make a new release"
  image: node:${NODE_VERSION}
  variables:
    GIT_AUTHOR_EMAIL: 45039513+SocialGroovyBot@users.noreply.github.com
    GIT_AUTHOR_NAME: Social Groovy Bot
    GIT_COMMITTER_EMAIL: ${GIT_AUTHOR_EMAIL}
    GIT_COMMITTER_NAME: ${GIT_AUTHOR_NAME}
  cache:
    key: "${CI_JOB_NAME}-${CI_COMMIT_REF_SLUG}"
    paths:
      - ${CI_PROJECT_DIR}/.yarn
  before_script:
    - git checkout ${CI_COMMIT_REF_NAME}
    - git config user.name "Social Groovy Bot"
    - git config user.email "45039513+SocialGroovyBot@users.noreply.github.com"
    - git remote set-url origin https://${GITHUB_TOKEN}@github.com/${CI_PROJECT_PATH}.git
  script:
    - yarn config set cache-folder ${CI_PROJECT_DIR}/.yarn
    - yarn --frozen-lockfile
    - GH_TOKEN=${GITHUB_TOKEN} yarn lerna version ${LERNA_ARGS:="--force-publish --yes"}
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - master
  when: manual


###########################################
###          DEPLOY TO PROD K8S         ###
###########################################

#
.prod_stage: &prod_stage
  image: ${CI_REGISTRY}/socialgouv/docker/helm:${HELM_VERSION}
  variables: &prod_stage_variables
    ENABLE_PERSISTENT_VOLUME: "true"
    APP_DOMAIN_NAME: fabrique.social.gouv.fr
    NAMESPACE_ENVIRONMENT: ${PROD_NAMESPACE_ENVIRONMENT}
    API_RESOURCE_CPU_LIMIT: "250m"
    API_RESOURCE_MEMORY_LIMIT: "256Mi"
    API_RESOURCE_CPU_REQUEST: "5m"
    API_RESOURCE_MEMORY_REQUEST: "16Mi"
    APP_RESOURCE_CPU_LIMIT: "250m"
    APP_RESOURCE_MEMORY_LIMIT: "256Mi"
    APP_RESOURCE_CPU_REQUEST: "5m"
    APP_RESOURCE_MEMORY_REQUEST: "16Mi"
    KINTO_RESOURCE_CPU_LIMIT: "500m"
    KINTO_RESOURCE_MEMORY_LIMIT: "512Mi"
    KINTO_RESOURCE_CPU_REQUEST: "10m"
    KINTO_RESOURCE_MEMORY_REQUEST: "32Mi"
    INIT_KINTO_RESOURCE_CPU_LIMIT: "20m"
    INIT_KINTO_RESOURCE_MEMORY_LIMIT: "16Mi"
    INIT_KINTO_RESOURCE_CPU_REQUEST: "10m"
    INIT_KINTO_RESOURCE_MEMORY_REQUEST: "8Mi"
    MEMCACHED_RESOURCE_CPU_LIMIT: "500m"
    MEMCACHED_RESOURCE_MEMORY_LIMIT: "256Mi"
    MEMCACHED_RESOURCE_CPU_REQUEST: "10m"
    MEMCACHED_RESOURCE_MEMORY_REQUEST: "32Mi"
    POSTGRES_RESOURCE_CPU_LIMIT: "500m"
    POSTGRES_RESOURCE_MEMORY_LIMIT: "512Mi"
    POSTGRES_RESOURCE_CPU_REQUEST: "25m"
    POSTGRES_RESOURCE_MEMORY_REQUEST: "128Mi"
  before_script:
    # set environment variables
    - export IMAGE_TAG=$(printf "${CI_COMMIT_TAG}" | sed "s/^v//")
    - export K8S_NAMESPACE=${STARTUP}-${NAMESPACE_ENVIRONMENT}
    - export APP_URL=${STARTUP}-${NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
    # azure volume secrets
    - export AZURE_STORAGE_ACCOUNT_NAME=$(kubectl get secret azure-${STARTUP}prod-volume -n ${STARTUP}-secret -ojsonpath='{.data.azurestorageaccountname}')
    - export AZURE_STORAGE_ACCOUNT_KEY=$(kubectl get secret azure-${STARTUP}prod-volume -n ${STARTUP}-secret -ojsonpath='{.data.azurestorageaccountkey}')
    - export CERTIFICATE_ENVIRONMENT=crt
    - envsubst < .k8s/secret/secret-azure-volume.yml > .k8s/secret/secret-azure-volume-${STARTUP}.yml
    # app
    - export PORT=${APP_PORT}
    - envsubst < .k8s/app/deployment.yml > .k8s/app/deployment-${STARTUP}.yml
    - envsubst < .k8s/app/service.yml > .k8s/app/service-${STARTUP}.yml
    - envsubst < .k8s/app/ingress.yml > .k8s/app/ingress-prod-${STARTUP}.yml
    - envsubst < .k8s/certificate/certificate-prod.yml > .k8s/certificate/certificate-${STARTUP}.yml
    # api
    - export PORT=${API_PORT}
    - envsubst < .k8s/api/deployment.yml > .k8s/api/deployment-${STARTUP}.yml
    - envsubst < .k8s/api/service.yml > .k8s/api/service-${STARTUP}.yml
    # memcached
    - envsubst < .k8s/memcached/values.yml > .k8s/memcached/values-${STARTUP}.yml
    # postgres
    - export POSTGRESQL_PASSWORD=$(kubectl get secret ${STARTUP} -n ${K8S_NAMESPACE} -o jsonpath='{.data.POSTGRES_EGAPRO_PASSWORD}' | base64 --decode)
    - envsubst < .k8s/postgres/values.yml > .k8s/postgres/values-${STARTUP}.yml
    # kinto
    - export PORT=${KINTO_PORT}
    - export POSTGRESQL_USER=$(kubectl get secret ${STARTUP} -n ${K8S_NAMESPACE} -o jsonpath='{.data.POSTGRES_EGAPRO_USER}' | base64 --decode)
    - envsubst < .k8s/kinto/deployment.yml > .k8s/kinto/deployment-${STARTUP}.yml
    - envsubst < .k8s/kinto/service.yml > .k8s/kinto/service-${STARTUP}.yml
    - envsubst < .k8s/kinto/job-init-kinto.yml > .k8s/kinto/job-init-kinto-${STARTUP}.yml
    - kubectl delete job init-kinto -n ${K8S_NAMESPACE} || true;
  environment:
    name: ${PROD_NAMESPACE_ENVIRONMENT}
  when: manual
  only:
    - /^v.*/
#

Deploy egapro in production :
  stage: "Deploy to prod K8S"
  <<: *prod_stage
  variables:
    <<: *prod_stage_variables
  script:
    # app
    - kubectl apply -f .k8s/app/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/app/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/app/ingress-prod-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/certificate/certificate-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=app -n ${K8S_NAMESPACE} --timeout=600s
    # api
    - kubectl apply -f .k8s/api/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/api/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=api -n ${K8S_NAMESPACE} --timeout=600s
    # postgres
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg --wait -f .k8s/postgres/values-${STARTUP}.yml stable/postgresql --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=postgres -n ${K8S_NAMESPACE} --timeout=600s
    # memcached
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-memcached --wait -f .k8s/memcached/values-${STARTUP}.yml stable/memcached --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=memcached -n ${K8S_NAMESPACE} --timeout=600s
    # kinto
    - kubectl apply -f .k8s/kinto/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/job-init-kinto-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=kinto -n ${K8S_NAMESPACE} --timeout=600s
    - kubectl wait --for=condition=complete job/init-kinto -n ${K8S_NAMESPACE} --timeout=600s

Restore egapro/postgres:
  stage: "Restore prod backup"
  <<: *prod_stage
  variables:
    <<: *prod_stage_variables
    PORT: ${KINTO_PORT}
  script:
    # delete old restore job, kinto and postgres
    - kubectl delete job restore-backup -n ${K8S_NAMESPACE} || true;
    - kubectl delete deploy kinto -n ${K8S_NAMESPACE} || true;
    - helm delete --purge ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg || true;
    - kubectl delete pvc data-${STARTUP}-prod-pg-postgresql-0 -n ${K8S_NAMESPACE} || true;
    # Create azure volume secrets
    - kubectl apply -f .k8s/secret/secret-azure-volume-${STARTUP}.yml -n ${K8S_NAMESPACE}
    # deploy clean postgres
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg --wait -f .k8s/postgres/values-${STARTUP}.yml stable/postgresql --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=postgres -n ${K8S_NAMESPACE} --timeout=600s
    # run restore job
    - envsubst < .k8s/postgres/restore-job.yml > .k8s/postgres/restore-job-${STARTUP}.yml
    - kubectl apply -f .k8s/postgres/restore-job-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=complete job/restore-backup --timeout=600s -n ${K8S_NAMESPACE}
    # deploy kinto
    - kubectl apply -f .k8s/kinto/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/job-init-kinto-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=complete job/init-kinto --timeout=600s -n ${K8S_NAMESPACE}
  only:
    - /^v.*/
  when: manual

...
