---

include:
  - /.gitlab-ci/variables.yml
#  - /.gitlab-ci/stages/01-quality.yml
  - /.gitlab-ci/stages/02-prepare.yml
  - /.gitlab-ci/stages/03-register.yml
  - /.gitlab-ci/stages/04-secret.yml
  - /.gitlab-ci/stages/05-deploy-dev.yml
  #
  - project: SocialGouv/gitlab-ci-yml
    file: /base_docker_kubectl_image_stage.yml
    ref: master
  - project: SocialGouv/gitlab-ci-yml
    file: /base_docker_helm_image_stage.yml
    ref: master
  - project: SocialGouv/gitlab-ci-yml
    file: /base_semantic_release_stage.yml
    ref: master
  - project: SocialGouv/gitlab-ci-yml
    file: /base_notify_github_stage.yml
    ref: master
  #
  - "/.gitlab-ci/.deploy-egapro-app.yml"
  - "/.gitlab-ci/.deploy-egapro-api.yml"
  - "/.gitlab-ci/.deploy-egapro-postgres.yml"
  - "/.gitlab-ci/.deploy-egapro-memcached.yml"
  - "/.gitlab-ci/.deploy-egapro-kinto.yml"

stages:
  - "Code Quality"
  - "Prepare"
  - "Registration"
  - "Create secret hors prod"
  - "Deploy to hors prod K8S"
  - "Notify Finished Deployment"
  - "Release"
  - "Deploy to prod K8S"
  - "Restore prod backup"


.resolve_env: &resolve_env |-
  set -x

  export BRANCH_NAME=${BRANCH_NAME:=$CI_COMMIT_REF_SLUG}
  export HASH_SIZE=${HASH_SIZE:=7}
  export K8S_PROJECT=${K8S_PROJECT:=$PROJECT}
  BRANCH_NAME_HASHED=$( printf "${BRANCH_NAME}" | sha1sum | cut -c1-${HASH_SIZE} )
  export BRANCH_HASH=${BRANCH_HASH:="$BRANCH_NAME_HASHED"}
  export K8S_NAMESPACE="${PROJECT}-feature-${BRANCH_HASH}"

  if [[ -n $PRODUCTION ]]; then
    export BRANCH_HASH=prod
    export K8S_NAMESPACE="${PROJECT}-${BRANCH_HASH}"
    export DOMAIN="${PROJECT}.fabrique.social.gouv.fr"

  elif [[ "${BRANCH_NAME}" = "egapro-auto-devops" ]]; then
    export BRANCH_HASH=master
    export K8S_NAMESPACE="${PROJECT}-${BRANCH_HASH}"
    export DOMAIN="${PROJECT}-master.dev.fabrique.social.gouv.fr"

  else
    export DOMAIN="${BRANCH_HASH}-${PROJECT}.dev.fabrique.social.gouv.fr"
  fi

  export HOST="${DOMAIN}"

  set +x

before_script:
  - *resolve_env

#############################################
#####         SEND URL TO GITHUB          ###
#############################################

Notify Starting Deployment:
  extends: .base_notify_pending_stage
  stage: Deploy to hors prod K8S

Notify Fail:
  extends: .base_notify_fail_stage
  stage: Notify Finished Deployment
  dependencies:
    - Notify Starting Deployment

Notify Success:
  extends: .base_notify_success_stage
  stage: Notify Finished Deployment
  dependencies:
    - Notify Starting Deployment

#.send_url_to_github_stage: &send_url_to_github_stage
#  stage: "Send Url to GitHub"
#  image: ${CI_REGISTRY}/${IMAGE_INFRA_BASE_NAME}/git-deploy:${INFRA_GIT_DEPLOY_VERSION}
#  script:
#    - export DEPLOY_ID=$(cat github_deploy_id)
#    - envsubst < /scripts/send-url.sh > /scripts/send-url-to-github.sh
#    - sh /scripts/send-url-to-github.sh
#
#
#Send deployment url to Github (dev):
#  <<: *send_url_to_github_stage
#  before_script:
#    - export NAMESPACE_ENVIRONMENT=${NAMESPACE_ENVIRONMENT:=$(printf "${CI_COMMIT_REF_NAME}" | sha1sum | cut -c1-5)}
#    - export URL=https://${STARTUP}-${NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
#  environment:
#    name: ${DEV_NAMESPACE_ENVIRONMENT}
#  only:
#    - branches
#  except:
#    - egapro-auto-devops
#
#Send deployment url to Github (master):
#  <<: *send_url_to_github_stage
#  before_script:
#    - export URL=https://${STARTUP}-${MASTER_NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
#  environment:
#    name: ${MASTER_NAMESPACE_ENVIRONMENT}
#  except:
#    variables:
#      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
#  only:
#    - egapro-auto-devops
#
#Send deployment url to Github (preprod):
#  <<: *send_url_to_github_stage
#  before_script:
#    - export URL=https://${STARTUP}-${PREPROD_NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
#  environment:
#    name: ${PREPROD_NAMESPACE_ENVIRONMENT}
#  only:
#    - /^v.*/


############################################
####           RELEASE VERSION           ###
############################################

Make a new release to deploy to preprod environment:
  extends: .base_semantic_release_stage
  except:
    variables:
      - $CI_COMMIT_MESSAGE =~ /^chore\(release.*/
  only:
    - egapro-auto-devops
  when: manual


###########################################
###          DEPLOY TO PROD K8S         ###
###########################################

#
.prod_stage: &prod_stage
  image: ${CI_REGISTRY}/socialgouv/docker/helm:${HELM_VERSION}
  variables: &prod_stage_variables
    ENABLE_PERSISTENT_VOLUME: "true"
    APP_DOMAIN_NAME: fabrique.social.gouv.fr
    NAMESPACE_ENVIRONMENT: ${PROD_NAMESPACE_ENVIRONMENT}
    API_RESOURCE_CPU_LIMIT: "250m"
    API_RESOURCE_MEMORY_LIMIT: "256Mi"
    API_RESOURCE_CPU_REQUEST: "5m"
    API_RESOURCE_MEMORY_REQUEST: "16Mi"
    APP_RESOURCE_CPU_LIMIT: "250m"
    APP_RESOURCE_MEMORY_LIMIT: "256Mi"
    APP_RESOURCE_CPU_REQUEST: "5m"
    APP_RESOURCE_MEMORY_REQUEST: "16Mi"
    KINTO_RESOURCE_CPU_LIMIT: "500m"
    KINTO_RESOURCE_MEMORY_LIMIT: "512Mi"
    KINTO_RESOURCE_CPU_REQUEST: "10m"
    KINTO_RESOURCE_MEMORY_REQUEST: "32Mi"
    INIT_KINTO_RESOURCE_CPU_LIMIT: "20m"
    INIT_KINTO_RESOURCE_MEMORY_LIMIT: "16Mi"
    INIT_KINTO_RESOURCE_CPU_REQUEST: "10m"
    INIT_KINTO_RESOURCE_MEMORY_REQUEST: "8Mi"
    MEMCACHED_RESOURCE_CPU_LIMIT: "500m"
    MEMCACHED_RESOURCE_MEMORY_LIMIT: "256Mi"
    MEMCACHED_RESOURCE_CPU_REQUEST: "10m"
    MEMCACHED_RESOURCE_MEMORY_REQUEST: "32Mi"
    POSTGRES_RESOURCE_CPU_LIMIT: "500m"
    POSTGRES_RESOURCE_MEMORY_LIMIT: "512Mi"
    POSTGRES_RESOURCE_CPU_REQUEST: "25m"
    POSTGRES_RESOURCE_MEMORY_REQUEST: "128Mi"
  before_script:
    # set environment variables
    - export IMAGE_TAG=$(printf "${CI_COMMIT_TAG}" | sed "s/^v//")
    - export K8S_NAMESPACE=${STARTUP}-${NAMESPACE_ENVIRONMENT}
    - export APP_URL=${STARTUP}-${NAMESPACE_ENVIRONMENT}.${APP_DOMAIN_NAME}
    # azure volume secrets
    - export AZURE_STORAGE_ACCOUNT_NAME=$(kubectl get secret azure-${STARTUP}prod-volume -n ${STARTUP}-secret -ojsonpath='{.data.azurestorageaccountname}')
    - export AZURE_STORAGE_ACCOUNT_KEY=$(kubectl get secret azure-${STARTUP}prod-volume -n ${STARTUP}-secret -ojsonpath='{.data.azurestorageaccountkey}')
    - export CERTIFICATE_ENVIRONMENT=crt
    - envsubst < .k8s/secret/secret-azure-volume.yml > .k8s/secret/secret-azure-volume-${STARTUP}.yml
    # app
    - export PORT=${APP_PORT}
    - envsubst < .k8s/app/deployment.yml > .k8s/app/deployment-${STARTUP}.yml
    - envsubst < .k8s/app/service.yml > .k8s/app/service-${STARTUP}.yml
    - envsubst < .k8s/app/ingress.yml > .k8s/app/ingress-prod-${STARTUP}.yml
    - envsubst < .k8s/certificate/certificate-prod.yml > .k8s/certificate/certificate-${STARTUP}.yml
    # api
    - export PORT=${API_PORT}
    - envsubst < .k8s/api/deployment.yml > .k8s/api/deployment-${STARTUP}.yml
    - envsubst < .k8s/api/service.yml > .k8s/api/service-${STARTUP}.yml
    # memcached
    - envsubst < .k8s/memcached/values.yml > .k8s/memcached/values-${STARTUP}.yml
    # postgres
    - export POSTGRESQL_PASSWORD=$(kubectl get secret ${STARTUP} -n ${K8S_NAMESPACE} -o jsonpath='{.data.POSTGRES_EGAPRO_PASSWORD}' | base64 --decode)
    - envsubst < .k8s/postgres/values.yml > .k8s/postgres/values-${STARTUP}.yml
    # kinto
    - export PORT=${KINTO_PORT}
    - export POSTGRESQL_USER=$(kubectl get secret ${STARTUP} -n ${K8S_NAMESPACE} -o jsonpath='{.data.POSTGRES_EGAPRO_USER}' | base64 --decode)
    - envsubst < .k8s/kinto/deployment.yml > .k8s/kinto/deployment-${STARTUP}.yml
    - envsubst < .k8s/kinto/service.yml > .k8s/kinto/service-${STARTUP}.yml
    - envsubst < .k8s/kinto/job-init-kinto.yml > .k8s/kinto/job-init-kinto-${STARTUP}.yml
    - kubectl delete job init-kinto -n ${K8S_NAMESPACE} || true;
  environment:
    name: ${PROD_NAMESPACE_ENVIRONMENT}
  when: manual
  only:
    - /^v.*/
#

Deploy egapro in production :
  stage: "Deploy to prod K8S"
  <<: *prod_stage
  variables:
    <<: *prod_stage_variables
  script:
    # app
    - kubectl apply -f .k8s/app/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/app/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/app/ingress-prod-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/certificate/certificate-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=app -n ${K8S_NAMESPACE} --timeout=600s
    # api
    - kubectl apply -f .k8s/api/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/api/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=api -n ${K8S_NAMESPACE} --timeout=600s
    # postgres
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg --wait -f .k8s/postgres/values-${STARTUP}.yml stable/postgresql --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=postgres -n ${K8S_NAMESPACE} --timeout=600s
    # memcached
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-memcached --wait -f .k8s/memcached/values-${STARTUP}.yml stable/memcached --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=memcached -n ${K8S_NAMESPACE} --timeout=600s
    # kinto
    - kubectl apply -f .k8s/kinto/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/job-init-kinto-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=kinto -n ${K8S_NAMESPACE} --timeout=600s
    - kubectl wait --for=condition=complete job/init-kinto -n ${K8S_NAMESPACE} --timeout=600s

Restore egapro/postgres:
  stage: "Restore prod backup"
  <<: *prod_stage
  variables:
    <<: *prod_stage_variables
    PORT: ${KINTO_PORT}
  script:
    # delete old restore job, kinto and postgres
    - kubectl delete job restore-backup -n ${K8S_NAMESPACE} || true;
    - kubectl delete deploy kinto -n ${K8S_NAMESPACE} || true;
    - helm delete --purge ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg || true;
    - kubectl delete pvc data-${STARTUP}-prod-pg-postgresql-0 -n ${K8S_NAMESPACE} || true;
    # Create azure volume secrets
    - kubectl apply -f .k8s/secret/secret-azure-volume-${STARTUP}.yml -n ${K8S_NAMESPACE}
    # deploy clean postgres
    - helm init --client-only
    - helm upgrade --install ${STARTUP}-${NAMESPACE_ENVIRONMENT}-pg --wait -f .k8s/postgres/values-${STARTUP}.yml stable/postgresql --namespace ${K8S_NAMESPACE}
    - kubectl wait --for=condition=Ready pod -l component=postgres -n ${K8S_NAMESPACE} --timeout=600s
    # run restore job
    - envsubst < .k8s/postgres/restore-job.yml > .k8s/postgres/restore-job-${STARTUP}.yml
    - kubectl apply -f .k8s/postgres/restore-job-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=complete job/restore-backup --timeout=600s -n ${K8S_NAMESPACE}
    # deploy kinto
    - kubectl apply -f .k8s/kinto/deployment-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/service-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl apply -f .k8s/kinto/job-init-kinto-${STARTUP}.yml -n ${K8S_NAMESPACE}
    - kubectl wait --for=condition=complete job/init-kinto --timeout=600s -n ${K8S_NAMESPACE}
  only:
    - /^v.*/
  when: manual

...
